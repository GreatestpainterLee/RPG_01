// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GamePackage

#ifndef PROTOBUF_GamePackage__INCLUDED
#define PROTOBUF_GamePackage__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GamePackage();
void protobuf_AssignDesc_GamePackage();
void protobuf_ShutdownFile_GamePackage();

class GamePackage;
class GamePackage_Player;
class GamePackage_Monster;
class GamePackage_Equipment;

// ===================================================================

class GamePackage_Player : public ::google::protobuf::Message {
 public:
  GamePackage_Player();
  virtual ~GamePackage_Player();

  GamePackage_Player(const GamePackage_Player& from);

  inline GamePackage_Player& operator=(const GamePackage_Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamePackage_Player& default_instance();

  void Swap(GamePackage_Player* other);

  // implements Message ----------------------------------------------

  GamePackage_Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamePackage_Player& from);
  void MergeFrom(const GamePackage_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string UserName = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string Password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional float Speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline float speed() const;
  inline void set_speed(float value);

  // optional int32 Direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional float DestPointX = 6;
  inline bool has_destpointx() const;
  inline void clear_destpointx();
  static const int kDestPointXFieldNumber = 6;
  inline float destpointx() const;
  inline void set_destpointx(float value);

  // optional float DestPointY = 7;
  inline bool has_destpointy() const;
  inline void clear_destpointy();
  static const int kDestPointYFieldNumber = 7;
  inline float destpointy() const;
  inline void set_destpointy(float value);

  // optional float CurrentPointX = 8;
  inline bool has_currentpointx() const;
  inline void clear_currentpointx();
  static const int kCurrentPointXFieldNumber = 8;
  inline float currentpointx() const;
  inline void set_currentpointx(float value);

  // optional float CurrentPointY = 9;
  inline bool has_currentpointy() const;
  inline void clear_currentpointy();
  static const int kCurrentPointYFieldNumber = 9;
  inline float currentpointy() const;
  inline void set_currentpointy(float value);

  // optional int32 MsgCode = 10;
  inline bool has_msgcode() const;
  inline void clear_msgcode();
  static const int kMsgCodeFieldNumber = 10;
  inline ::google::protobuf::int32 msgcode() const;
  inline void set_msgcode(::google::protobuf::int32 value);

  // optional int32 PreDirection = 11;
  inline bool has_predirection() const;
  inline void clear_predirection();
  static const int kPreDirectionFieldNumber = 11;
  inline ::google::protobuf::int32 predirection() const;
  inline void set_predirection(::google::protobuf::int32 value);

  // optional int32 PreEvent = 12;
  inline bool has_preevent() const;
  inline void clear_preevent();
  static const int kPreEventFieldNumber = 12;
  inline ::google::protobuf::int32 preevent() const;
  inline void set_preevent(::google::protobuf::int32 value);

  // optional float BloodValue = 13;
  inline bool has_bloodvalue() const;
  inline void clear_bloodvalue();
  static const int kBloodValueFieldNumber = 13;
  inline float bloodvalue() const;
  inline void set_bloodvalue(float value);

  // optional float MaxBloodValue = 14;
  inline bool has_maxbloodvalue() const;
  inline void clear_maxbloodvalue();
  static const int kMaxBloodValueFieldNumber = 14;
  inline float maxbloodvalue() const;
  inline void set_maxbloodvalue(float value);

  // optional float MagicValue = 15;
  inline bool has_magicvalue() const;
  inline void clear_magicvalue();
  static const int kMagicValueFieldNumber = 15;
  inline float magicvalue() const;
  inline void set_magicvalue(float value);

  // optional float MaxMagicValue = 16;
  inline bool has_maxmagicvalue() const;
  inline void clear_maxmagicvalue();
  static const int kMaxMagicValueFieldNumber = 16;
  inline float maxmagicvalue() const;
  inline void set_maxmagicvalue(float value);

  // optional float EmpiricalValue = 17;
  inline bool has_empiricalvalue() const;
  inline void clear_empiricalvalue();
  static const int kEmpiricalValueFieldNumber = 17;
  inline float empiricalvalue() const;
  inline void set_empiricalvalue(float value);

  // optional float MaxEmpiricalValue = 18;
  inline bool has_maxempiricalvalue() const;
  inline void clear_maxempiricalvalue();
  static const int kMaxEmpiricalValueFieldNumber = 18;
  inline float maxempiricalvalue() const;
  inline void set_maxempiricalvalue(float value);

  // optional int32 Level = 19;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 19;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional float DamageValue = 20;
  inline bool has_damagevalue() const;
  inline void clear_damagevalue();
  static const int kDamageValueFieldNumber = 20;
  inline float damagevalue() const;
  inline void set_damagevalue(float value);

  // optional int32 Skill = 21;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 21;
  inline ::google::protobuf::int32 skill() const;
  inline void set_skill(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GamePackage.Player)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_destpointx();
  inline void clear_has_destpointx();
  inline void set_has_destpointy();
  inline void clear_has_destpointy();
  inline void set_has_currentpointx();
  inline void clear_has_currentpointx();
  inline void set_has_currentpointy();
  inline void clear_has_currentpointy();
  inline void set_has_msgcode();
  inline void clear_has_msgcode();
  inline void set_has_predirection();
  inline void clear_has_predirection();
  inline void set_has_preevent();
  inline void clear_has_preevent();
  inline void set_has_bloodvalue();
  inline void clear_has_bloodvalue();
  inline void set_has_maxbloodvalue();
  inline void clear_has_maxbloodvalue();
  inline void set_has_magicvalue();
  inline void clear_has_magicvalue();
  inline void set_has_maxmagicvalue();
  inline void clear_has_maxmagicvalue();
  inline void set_has_empiricalvalue();
  inline void clear_has_empiricalvalue();
  inline void set_has_maxempiricalvalue();
  inline void clear_has_maxempiricalvalue();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_damagevalue();
  inline void clear_has_damagevalue();
  inline void set_has_skill();
  inline void clear_has_skill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* username_;
  ::std::string* password_;
  float speed_;
  ::google::protobuf::int32 direction_;
  float destpointx_;
  float destpointy_;
  float currentpointx_;
  float currentpointy_;
  ::google::protobuf::int32 msgcode_;
  ::google::protobuf::int32 predirection_;
  ::google::protobuf::int32 preevent_;
  float bloodvalue_;
  float maxbloodvalue_;
  float magicvalue_;
  float maxmagicvalue_;
  float empiricalvalue_;
  float maxempiricalvalue_;
  ::google::protobuf::int32 level_;
  float damagevalue_;
  ::google::protobuf::int32 skill_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_GamePackage();
  friend void protobuf_AssignDesc_GamePackage();
  friend void protobuf_ShutdownFile_GamePackage();

  void InitAsDefaultInstance();
  static GamePackage_Player* default_instance_;
};
// -------------------------------------------------------------------

class GamePackage_Monster : public ::google::protobuf::Message {
 public:
  GamePackage_Monster();
  virtual ~GamePackage_Monster();

  GamePackage_Monster(const GamePackage_Monster& from);

  inline GamePackage_Monster& operator=(const GamePackage_Monster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamePackage_Monster& default_instance();

  void Swap(GamePackage_Monster* other);

  // implements Message ----------------------------------------------

  GamePackage_Monster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamePackage_Monster& from);
  void MergeFrom(const GamePackage_Monster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 PreDirection = 1;
  inline bool has_predirection() const;
  inline void clear_predirection();
  static const int kPreDirectionFieldNumber = 1;
  inline ::google::protobuf::int32 predirection() const;
  inline void set_predirection(::google::protobuf::int32 value);

  // optional int32 PreEvent = 2;
  inline bool has_preevent() const;
  inline void clear_preevent();
  static const int kPreEventFieldNumber = 2;
  inline ::google::protobuf::int32 preevent() const;
  inline void set_preevent(::google::protobuf::int32 value);

  // optional int32 MonsterType = 3;
  inline bool has_monstertype() const;
  inline void clear_monstertype();
  static const int kMonsterTypeFieldNumber = 3;
  inline ::google::protobuf::int32 monstertype() const;
  inline void set_monstertype(::google::protobuf::int32 value);

  // optional string MonsterName = 4;
  inline bool has_monstername() const;
  inline void clear_monstername();
  static const int kMonsterNameFieldNumber = 4;
  inline const ::std::string& monstername() const;
  inline void set_monstername(const ::std::string& value);
  inline void set_monstername(const char* value);
  inline void set_monstername(const char* value, size_t size);
  inline ::std::string* mutable_monstername();
  inline ::std::string* release_monstername();
  inline void set_allocated_monstername(::std::string* monstername);

  // optional float Speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline float speed() const;
  inline void set_speed(float value);

  // optional int32 Direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional float DestPointX = 7;
  inline bool has_destpointx() const;
  inline void clear_destpointx();
  static const int kDestPointXFieldNumber = 7;
  inline float destpointx() const;
  inline void set_destpointx(float value);

  // optional float DestPointY = 8;
  inline bool has_destpointy() const;
  inline void clear_destpointy();
  static const int kDestPointYFieldNumber = 8;
  inline float destpointy() const;
  inline void set_destpointy(float value);

  // optional float CurrentPointX = 9;
  inline bool has_currentpointx() const;
  inline void clear_currentpointx();
  static const int kCurrentPointXFieldNumber = 9;
  inline float currentpointx() const;
  inline void set_currentpointx(float value);

  // optional float CurrentPointY = 10;
  inline bool has_currentpointy() const;
  inline void clear_currentpointy();
  static const int kCurrentPointYFieldNumber = 10;
  inline float currentpointy() const;
  inline void set_currentpointy(float value);

  // optional int32 Event = 11;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 11;
  inline ::google::protobuf::int32 event() const;
  inline void set_event(::google::protobuf::int32 value);

  // optional float BloodValue = 12;
  inline bool has_bloodvalue() const;
  inline void clear_bloodvalue();
  static const int kBloodValueFieldNumber = 12;
  inline float bloodvalue() const;
  inline void set_bloodvalue(float value);

  // optional float MaxBloodValue = 13;
  inline bool has_maxbloodvalue() const;
  inline void clear_maxbloodvalue();
  static const int kMaxBloodValueFieldNumber = 13;
  inline float maxbloodvalue() const;
  inline void set_maxbloodvalue(float value);

  // optional int32 Level = 14;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 14;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional float EmpiricalValue = 15;
  inline bool has_empiricalvalue() const;
  inline void clear_empiricalvalue();
  static const int kEmpiricalValueFieldNumber = 15;
  inline float empiricalvalue() const;
  inline void set_empiricalvalue(float value);

  // optional float DamageValue = 16;
  inline bool has_damagevalue() const;
  inline void clear_damagevalue();
  static const int kDamageValueFieldNumber = 16;
  inline float damagevalue() const;
  inline void set_damagevalue(float value);

  // @@protoc_insertion_point(class_scope:GamePackage.Monster)
 private:
  inline void set_has_predirection();
  inline void clear_has_predirection();
  inline void set_has_preevent();
  inline void clear_has_preevent();
  inline void set_has_monstertype();
  inline void clear_has_monstertype();
  inline void set_has_monstername();
  inline void clear_has_monstername();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_destpointx();
  inline void clear_has_destpointx();
  inline void set_has_destpointy();
  inline void clear_has_destpointy();
  inline void set_has_currentpointx();
  inline void clear_has_currentpointx();
  inline void set_has_currentpointy();
  inline void clear_has_currentpointy();
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_bloodvalue();
  inline void clear_has_bloodvalue();
  inline void set_has_maxbloodvalue();
  inline void clear_has_maxbloodvalue();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_empiricalvalue();
  inline void clear_has_empiricalvalue();
  inline void set_has_damagevalue();
  inline void clear_has_damagevalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 predirection_;
  ::google::protobuf::int32 preevent_;
  ::std::string* monstername_;
  ::google::protobuf::int32 monstertype_;
  float speed_;
  ::google::protobuf::int32 direction_;
  float destpointx_;
  float destpointy_;
  float currentpointx_;
  float currentpointy_;
  ::google::protobuf::int32 event_;
  float bloodvalue_;
  float maxbloodvalue_;
  ::google::protobuf::int32 level_;
  float empiricalvalue_;
  float damagevalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_GamePackage();
  friend void protobuf_AssignDesc_GamePackage();
  friend void protobuf_ShutdownFile_GamePackage();

  void InitAsDefaultInstance();
  static GamePackage_Monster* default_instance_;
};
// -------------------------------------------------------------------

class GamePackage_Equipment : public ::google::protobuf::Message {
 public:
  GamePackage_Equipment();
  virtual ~GamePackage_Equipment();

  GamePackage_Equipment(const GamePackage_Equipment& from);

  inline GamePackage_Equipment& operator=(const GamePackage_Equipment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamePackage_Equipment& default_instance();

  void Swap(GamePackage_Equipment* other);

  // implements Message ----------------------------------------------

  GamePackage_Equipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamePackage_Equipment& from);
  void MergeFrom(const GamePackage_Equipment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 EquipmentType = 1;
  inline bool has_equipmenttype() const;
  inline void clear_equipmenttype();
  static const int kEquipmentTypeFieldNumber = 1;
  inline ::google::protobuf::int32 equipmenttype() const;
  inline void set_equipmenttype(::google::protobuf::int32 value);

  // optional int32 ReturnBlood = 2;
  inline bool has_returnblood() const;
  inline void clear_returnblood();
  static const int kReturnBloodFieldNumber = 2;
  inline ::google::protobuf::int32 returnblood() const;
  inline void set_returnblood(::google::protobuf::int32 value);

  // optional int32 ReturnMagic = 3;
  inline bool has_returnmagic() const;
  inline void clear_returnmagic();
  static const int kReturnMagicFieldNumber = 3;
  inline ::google::protobuf::int32 returnmagic() const;
  inline void set_returnmagic(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GamePackage.Equipment)
 private:
  inline void set_has_equipmenttype();
  inline void clear_has_equipmenttype();
  inline void set_has_returnblood();
  inline void clear_has_returnblood();
  inline void set_has_returnmagic();
  inline void clear_has_returnmagic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 equipmenttype_;
  ::google::protobuf::int32 returnblood_;
  ::google::protobuf::int32 returnmagic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GamePackage();
  friend void protobuf_AssignDesc_GamePackage();
  friend void protobuf_ShutdownFile_GamePackage();

  void InitAsDefaultInstance();
  static GamePackage_Equipment* default_instance_;
};
// -------------------------------------------------------------------

class GamePackage : public ::google::protobuf::Message {
 public:
  GamePackage();
  virtual ~GamePackage();

  GamePackage(const GamePackage& from);

  inline GamePackage& operator=(const GamePackage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamePackage& default_instance();

  void Swap(GamePackage* other);

  // implements Message ----------------------------------------------

  GamePackage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamePackage& from);
  void MergeFrom(const GamePackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GamePackage_Player Player;
  typedef GamePackage_Monster Monster;
  typedef GamePackage_Equipment Equipment;

  // accessors -------------------------------------------------------

  // repeated .GamePackage.Player PlayerList = 1;
  inline int playerlist_size() const;
  inline void clear_playerlist();
  static const int kPlayerListFieldNumber = 1;
  inline const ::GamePackage_Player& playerlist(int index) const;
  inline ::GamePackage_Player* mutable_playerlist(int index);
  inline ::GamePackage_Player* add_playerlist();
  inline const ::google::protobuf::RepeatedPtrField< ::GamePackage_Player >&
      playerlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::GamePackage_Player >*
      mutable_playerlist();

  // repeated .GamePackage.Monster MonsterList = 2;
  inline int monsterlist_size() const;
  inline void clear_monsterlist();
  static const int kMonsterListFieldNumber = 2;
  inline const ::GamePackage_Monster& monsterlist(int index) const;
  inline ::GamePackage_Monster* mutable_monsterlist(int index);
  inline ::GamePackage_Monster* add_monsterlist();
  inline const ::google::protobuf::RepeatedPtrField< ::GamePackage_Monster >&
      monsterlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::GamePackage_Monster >*
      mutable_monsterlist();

  // @@protoc_insertion_point(class_scope:GamePackage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::GamePackage_Player > playerlist_;
  ::google::protobuf::RepeatedPtrField< ::GamePackage_Monster > monsterlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GamePackage();
  friend void protobuf_AssignDesc_GamePackage();
  friend void protobuf_ShutdownFile_GamePackage();

  void InitAsDefaultInstance();
  static GamePackage* default_instance_;
};
// ===================================================================


// ===================================================================

// GamePackage_Player

// optional string UserID = 1;
inline bool GamePackage_Player::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePackage_Player::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePackage_Player::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePackage_Player::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& GamePackage_Player::userid() const {
  return *userid_;
}
inline void GamePackage_Player::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GamePackage_Player::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GamePackage_Player::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePackage_Player::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* GamePackage_Player::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePackage_Player::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string UserName = 2;
inline bool GamePackage_Player::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePackage_Player::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePackage_Player::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePackage_Player::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& GamePackage_Player::username() const {
  return *username_;
}
inline void GamePackage_Player::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GamePackage_Player::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GamePackage_Player::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePackage_Player::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* GamePackage_Player::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePackage_Player::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Password = 3;
inline bool GamePackage_Player::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePackage_Player::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePackage_Player::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePackage_Player::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& GamePackage_Player::password() const {
  return *password_;
}
inline void GamePackage_Player::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GamePackage_Player::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GamePackage_Player::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePackage_Player::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* GamePackage_Player::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePackage_Player::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float Speed = 4;
inline bool GamePackage_Player::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GamePackage_Player::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GamePackage_Player::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GamePackage_Player::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float GamePackage_Player::speed() const {
  return speed_;
}
inline void GamePackage_Player::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 Direction = 5;
inline bool GamePackage_Player::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GamePackage_Player::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GamePackage_Player::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GamePackage_Player::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 GamePackage_Player::direction() const {
  return direction_;
}
inline void GamePackage_Player::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional float DestPointX = 6;
inline bool GamePackage_Player::has_destpointx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GamePackage_Player::set_has_destpointx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GamePackage_Player::clear_has_destpointx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GamePackage_Player::clear_destpointx() {
  destpointx_ = 0;
  clear_has_destpointx();
}
inline float GamePackage_Player::destpointx() const {
  return destpointx_;
}
inline void GamePackage_Player::set_destpointx(float value) {
  set_has_destpointx();
  destpointx_ = value;
}

// optional float DestPointY = 7;
inline bool GamePackage_Player::has_destpointy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GamePackage_Player::set_has_destpointy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GamePackage_Player::clear_has_destpointy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GamePackage_Player::clear_destpointy() {
  destpointy_ = 0;
  clear_has_destpointy();
}
inline float GamePackage_Player::destpointy() const {
  return destpointy_;
}
inline void GamePackage_Player::set_destpointy(float value) {
  set_has_destpointy();
  destpointy_ = value;
}

// optional float CurrentPointX = 8;
inline bool GamePackage_Player::has_currentpointx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GamePackage_Player::set_has_currentpointx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GamePackage_Player::clear_has_currentpointx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GamePackage_Player::clear_currentpointx() {
  currentpointx_ = 0;
  clear_has_currentpointx();
}
inline float GamePackage_Player::currentpointx() const {
  return currentpointx_;
}
inline void GamePackage_Player::set_currentpointx(float value) {
  set_has_currentpointx();
  currentpointx_ = value;
}

// optional float CurrentPointY = 9;
inline bool GamePackage_Player::has_currentpointy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GamePackage_Player::set_has_currentpointy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GamePackage_Player::clear_has_currentpointy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GamePackage_Player::clear_currentpointy() {
  currentpointy_ = 0;
  clear_has_currentpointy();
}
inline float GamePackage_Player::currentpointy() const {
  return currentpointy_;
}
inline void GamePackage_Player::set_currentpointy(float value) {
  set_has_currentpointy();
  currentpointy_ = value;
}

// optional int32 MsgCode = 10;
inline bool GamePackage_Player::has_msgcode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GamePackage_Player::set_has_msgcode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GamePackage_Player::clear_has_msgcode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GamePackage_Player::clear_msgcode() {
  msgcode_ = 0;
  clear_has_msgcode();
}
inline ::google::protobuf::int32 GamePackage_Player::msgcode() const {
  return msgcode_;
}
inline void GamePackage_Player::set_msgcode(::google::protobuf::int32 value) {
  set_has_msgcode();
  msgcode_ = value;
}

// optional int32 PreDirection = 11;
inline bool GamePackage_Player::has_predirection() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GamePackage_Player::set_has_predirection() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GamePackage_Player::clear_has_predirection() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GamePackage_Player::clear_predirection() {
  predirection_ = 0;
  clear_has_predirection();
}
inline ::google::protobuf::int32 GamePackage_Player::predirection() const {
  return predirection_;
}
inline void GamePackage_Player::set_predirection(::google::protobuf::int32 value) {
  set_has_predirection();
  predirection_ = value;
}

// optional int32 PreEvent = 12;
inline bool GamePackage_Player::has_preevent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GamePackage_Player::set_has_preevent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GamePackage_Player::clear_has_preevent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GamePackage_Player::clear_preevent() {
  preevent_ = 0;
  clear_has_preevent();
}
inline ::google::protobuf::int32 GamePackage_Player::preevent() const {
  return preevent_;
}
inline void GamePackage_Player::set_preevent(::google::protobuf::int32 value) {
  set_has_preevent();
  preevent_ = value;
}

// optional float BloodValue = 13;
inline bool GamePackage_Player::has_bloodvalue() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GamePackage_Player::set_has_bloodvalue() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GamePackage_Player::clear_has_bloodvalue() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GamePackage_Player::clear_bloodvalue() {
  bloodvalue_ = 0;
  clear_has_bloodvalue();
}
inline float GamePackage_Player::bloodvalue() const {
  return bloodvalue_;
}
inline void GamePackage_Player::set_bloodvalue(float value) {
  set_has_bloodvalue();
  bloodvalue_ = value;
}

// optional float MaxBloodValue = 14;
inline bool GamePackage_Player::has_maxbloodvalue() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GamePackage_Player::set_has_maxbloodvalue() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GamePackage_Player::clear_has_maxbloodvalue() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GamePackage_Player::clear_maxbloodvalue() {
  maxbloodvalue_ = 0;
  clear_has_maxbloodvalue();
}
inline float GamePackage_Player::maxbloodvalue() const {
  return maxbloodvalue_;
}
inline void GamePackage_Player::set_maxbloodvalue(float value) {
  set_has_maxbloodvalue();
  maxbloodvalue_ = value;
}

// optional float MagicValue = 15;
inline bool GamePackage_Player::has_magicvalue() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GamePackage_Player::set_has_magicvalue() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GamePackage_Player::clear_has_magicvalue() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GamePackage_Player::clear_magicvalue() {
  magicvalue_ = 0;
  clear_has_magicvalue();
}
inline float GamePackage_Player::magicvalue() const {
  return magicvalue_;
}
inline void GamePackage_Player::set_magicvalue(float value) {
  set_has_magicvalue();
  magicvalue_ = value;
}

// optional float MaxMagicValue = 16;
inline bool GamePackage_Player::has_maxmagicvalue() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GamePackage_Player::set_has_maxmagicvalue() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GamePackage_Player::clear_has_maxmagicvalue() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GamePackage_Player::clear_maxmagicvalue() {
  maxmagicvalue_ = 0;
  clear_has_maxmagicvalue();
}
inline float GamePackage_Player::maxmagicvalue() const {
  return maxmagicvalue_;
}
inline void GamePackage_Player::set_maxmagicvalue(float value) {
  set_has_maxmagicvalue();
  maxmagicvalue_ = value;
}

// optional float EmpiricalValue = 17;
inline bool GamePackage_Player::has_empiricalvalue() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GamePackage_Player::set_has_empiricalvalue() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GamePackage_Player::clear_has_empiricalvalue() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GamePackage_Player::clear_empiricalvalue() {
  empiricalvalue_ = 0;
  clear_has_empiricalvalue();
}
inline float GamePackage_Player::empiricalvalue() const {
  return empiricalvalue_;
}
inline void GamePackage_Player::set_empiricalvalue(float value) {
  set_has_empiricalvalue();
  empiricalvalue_ = value;
}

// optional float MaxEmpiricalValue = 18;
inline bool GamePackage_Player::has_maxempiricalvalue() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GamePackage_Player::set_has_maxempiricalvalue() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GamePackage_Player::clear_has_maxempiricalvalue() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GamePackage_Player::clear_maxempiricalvalue() {
  maxempiricalvalue_ = 0;
  clear_has_maxempiricalvalue();
}
inline float GamePackage_Player::maxempiricalvalue() const {
  return maxempiricalvalue_;
}
inline void GamePackage_Player::set_maxempiricalvalue(float value) {
  set_has_maxempiricalvalue();
  maxempiricalvalue_ = value;
}

// optional int32 Level = 19;
inline bool GamePackage_Player::has_level() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GamePackage_Player::set_has_level() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GamePackage_Player::clear_has_level() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GamePackage_Player::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GamePackage_Player::level() const {
  return level_;
}
inline void GamePackage_Player::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional float DamageValue = 20;
inline bool GamePackage_Player::has_damagevalue() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GamePackage_Player::set_has_damagevalue() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GamePackage_Player::clear_has_damagevalue() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GamePackage_Player::clear_damagevalue() {
  damagevalue_ = 0;
  clear_has_damagevalue();
}
inline float GamePackage_Player::damagevalue() const {
  return damagevalue_;
}
inline void GamePackage_Player::set_damagevalue(float value) {
  set_has_damagevalue();
  damagevalue_ = value;
}

// optional int32 Skill = 21;
inline bool GamePackage_Player::has_skill() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GamePackage_Player::set_has_skill() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GamePackage_Player::clear_has_skill() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GamePackage_Player::clear_skill() {
  skill_ = 0;
  clear_has_skill();
}
inline ::google::protobuf::int32 GamePackage_Player::skill() const {
  return skill_;
}
inline void GamePackage_Player::set_skill(::google::protobuf::int32 value) {
  set_has_skill();
  skill_ = value;
}

// -------------------------------------------------------------------

// GamePackage_Monster

// optional int32 PreDirection = 1;
inline bool GamePackage_Monster::has_predirection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePackage_Monster::set_has_predirection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePackage_Monster::clear_has_predirection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePackage_Monster::clear_predirection() {
  predirection_ = 0;
  clear_has_predirection();
}
inline ::google::protobuf::int32 GamePackage_Monster::predirection() const {
  return predirection_;
}
inline void GamePackage_Monster::set_predirection(::google::protobuf::int32 value) {
  set_has_predirection();
  predirection_ = value;
}

// optional int32 PreEvent = 2;
inline bool GamePackage_Monster::has_preevent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePackage_Monster::set_has_preevent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePackage_Monster::clear_has_preevent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePackage_Monster::clear_preevent() {
  preevent_ = 0;
  clear_has_preevent();
}
inline ::google::protobuf::int32 GamePackage_Monster::preevent() const {
  return preevent_;
}
inline void GamePackage_Monster::set_preevent(::google::protobuf::int32 value) {
  set_has_preevent();
  preevent_ = value;
}

// optional int32 MonsterType = 3;
inline bool GamePackage_Monster::has_monstertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePackage_Monster::set_has_monstertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePackage_Monster::clear_has_monstertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePackage_Monster::clear_monstertype() {
  monstertype_ = 0;
  clear_has_monstertype();
}
inline ::google::protobuf::int32 GamePackage_Monster::monstertype() const {
  return monstertype_;
}
inline void GamePackage_Monster::set_monstertype(::google::protobuf::int32 value) {
  set_has_monstertype();
  monstertype_ = value;
}

// optional string MonsterName = 4;
inline bool GamePackage_Monster::has_monstername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GamePackage_Monster::set_has_monstername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GamePackage_Monster::clear_has_monstername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GamePackage_Monster::clear_monstername() {
  if (monstername_ != &::google::protobuf::internal::kEmptyString) {
    monstername_->clear();
  }
  clear_has_monstername();
}
inline const ::std::string& GamePackage_Monster::monstername() const {
  return *monstername_;
}
inline void GamePackage_Monster::set_monstername(const ::std::string& value) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(value);
}
inline void GamePackage_Monster::set_monstername(const char* value) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(value);
}
inline void GamePackage_Monster::set_monstername(const char* value, size_t size) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePackage_Monster::mutable_monstername() {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  return monstername_;
}
inline ::std::string* GamePackage_Monster::release_monstername() {
  clear_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monstername_;
    monstername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePackage_Monster::set_allocated_monstername(::std::string* monstername) {
  if (monstername_ != &::google::protobuf::internal::kEmptyString) {
    delete monstername_;
  }
  if (monstername) {
    set_has_monstername();
    monstername_ = monstername;
  } else {
    clear_has_monstername();
    monstername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float Speed = 5;
inline bool GamePackage_Monster::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GamePackage_Monster::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GamePackage_Monster::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GamePackage_Monster::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float GamePackage_Monster::speed() const {
  return speed_;
}
inline void GamePackage_Monster::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 Direction = 6;
inline bool GamePackage_Monster::has_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GamePackage_Monster::set_has_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GamePackage_Monster::clear_has_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GamePackage_Monster::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 GamePackage_Monster::direction() const {
  return direction_;
}
inline void GamePackage_Monster::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional float DestPointX = 7;
inline bool GamePackage_Monster::has_destpointx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GamePackage_Monster::set_has_destpointx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GamePackage_Monster::clear_has_destpointx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GamePackage_Monster::clear_destpointx() {
  destpointx_ = 0;
  clear_has_destpointx();
}
inline float GamePackage_Monster::destpointx() const {
  return destpointx_;
}
inline void GamePackage_Monster::set_destpointx(float value) {
  set_has_destpointx();
  destpointx_ = value;
}

// optional float DestPointY = 8;
inline bool GamePackage_Monster::has_destpointy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GamePackage_Monster::set_has_destpointy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GamePackage_Monster::clear_has_destpointy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GamePackage_Monster::clear_destpointy() {
  destpointy_ = 0;
  clear_has_destpointy();
}
inline float GamePackage_Monster::destpointy() const {
  return destpointy_;
}
inline void GamePackage_Monster::set_destpointy(float value) {
  set_has_destpointy();
  destpointy_ = value;
}

// optional float CurrentPointX = 9;
inline bool GamePackage_Monster::has_currentpointx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GamePackage_Monster::set_has_currentpointx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GamePackage_Monster::clear_has_currentpointx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GamePackage_Monster::clear_currentpointx() {
  currentpointx_ = 0;
  clear_has_currentpointx();
}
inline float GamePackage_Monster::currentpointx() const {
  return currentpointx_;
}
inline void GamePackage_Monster::set_currentpointx(float value) {
  set_has_currentpointx();
  currentpointx_ = value;
}

// optional float CurrentPointY = 10;
inline bool GamePackage_Monster::has_currentpointy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GamePackage_Monster::set_has_currentpointy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GamePackage_Monster::clear_has_currentpointy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GamePackage_Monster::clear_currentpointy() {
  currentpointy_ = 0;
  clear_has_currentpointy();
}
inline float GamePackage_Monster::currentpointy() const {
  return currentpointy_;
}
inline void GamePackage_Monster::set_currentpointy(float value) {
  set_has_currentpointy();
  currentpointy_ = value;
}

// optional int32 Event = 11;
inline bool GamePackage_Monster::has_event() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GamePackage_Monster::set_has_event() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GamePackage_Monster::clear_has_event() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GamePackage_Monster::clear_event() {
  event_ = 0;
  clear_has_event();
}
inline ::google::protobuf::int32 GamePackage_Monster::event() const {
  return event_;
}
inline void GamePackage_Monster::set_event(::google::protobuf::int32 value) {
  set_has_event();
  event_ = value;
}

// optional float BloodValue = 12;
inline bool GamePackage_Monster::has_bloodvalue() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GamePackage_Monster::set_has_bloodvalue() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GamePackage_Monster::clear_has_bloodvalue() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GamePackage_Monster::clear_bloodvalue() {
  bloodvalue_ = 0;
  clear_has_bloodvalue();
}
inline float GamePackage_Monster::bloodvalue() const {
  return bloodvalue_;
}
inline void GamePackage_Monster::set_bloodvalue(float value) {
  set_has_bloodvalue();
  bloodvalue_ = value;
}

// optional float MaxBloodValue = 13;
inline bool GamePackage_Monster::has_maxbloodvalue() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GamePackage_Monster::set_has_maxbloodvalue() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GamePackage_Monster::clear_has_maxbloodvalue() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GamePackage_Monster::clear_maxbloodvalue() {
  maxbloodvalue_ = 0;
  clear_has_maxbloodvalue();
}
inline float GamePackage_Monster::maxbloodvalue() const {
  return maxbloodvalue_;
}
inline void GamePackage_Monster::set_maxbloodvalue(float value) {
  set_has_maxbloodvalue();
  maxbloodvalue_ = value;
}

// optional int32 Level = 14;
inline bool GamePackage_Monster::has_level() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GamePackage_Monster::set_has_level() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GamePackage_Monster::clear_has_level() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GamePackage_Monster::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GamePackage_Monster::level() const {
  return level_;
}
inline void GamePackage_Monster::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional float EmpiricalValue = 15;
inline bool GamePackage_Monster::has_empiricalvalue() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GamePackage_Monster::set_has_empiricalvalue() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GamePackage_Monster::clear_has_empiricalvalue() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GamePackage_Monster::clear_empiricalvalue() {
  empiricalvalue_ = 0;
  clear_has_empiricalvalue();
}
inline float GamePackage_Monster::empiricalvalue() const {
  return empiricalvalue_;
}
inline void GamePackage_Monster::set_empiricalvalue(float value) {
  set_has_empiricalvalue();
  empiricalvalue_ = value;
}

// optional float DamageValue = 16;
inline bool GamePackage_Monster::has_damagevalue() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GamePackage_Monster::set_has_damagevalue() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GamePackage_Monster::clear_has_damagevalue() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GamePackage_Monster::clear_damagevalue() {
  damagevalue_ = 0;
  clear_has_damagevalue();
}
inline float GamePackage_Monster::damagevalue() const {
  return damagevalue_;
}
inline void GamePackage_Monster::set_damagevalue(float value) {
  set_has_damagevalue();
  damagevalue_ = value;
}

// -------------------------------------------------------------------

// GamePackage_Equipment

// optional int32 EquipmentType = 1;
inline bool GamePackage_Equipment::has_equipmenttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePackage_Equipment::set_has_equipmenttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePackage_Equipment::clear_has_equipmenttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePackage_Equipment::clear_equipmenttype() {
  equipmenttype_ = 0;
  clear_has_equipmenttype();
}
inline ::google::protobuf::int32 GamePackage_Equipment::equipmenttype() const {
  return equipmenttype_;
}
inline void GamePackage_Equipment::set_equipmenttype(::google::protobuf::int32 value) {
  set_has_equipmenttype();
  equipmenttype_ = value;
}

// optional int32 ReturnBlood = 2;
inline bool GamePackage_Equipment::has_returnblood() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePackage_Equipment::set_has_returnblood() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePackage_Equipment::clear_has_returnblood() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePackage_Equipment::clear_returnblood() {
  returnblood_ = 0;
  clear_has_returnblood();
}
inline ::google::protobuf::int32 GamePackage_Equipment::returnblood() const {
  return returnblood_;
}
inline void GamePackage_Equipment::set_returnblood(::google::protobuf::int32 value) {
  set_has_returnblood();
  returnblood_ = value;
}

// optional int32 ReturnMagic = 3;
inline bool GamePackage_Equipment::has_returnmagic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePackage_Equipment::set_has_returnmagic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePackage_Equipment::clear_has_returnmagic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePackage_Equipment::clear_returnmagic() {
  returnmagic_ = 0;
  clear_has_returnmagic();
}
inline ::google::protobuf::int32 GamePackage_Equipment::returnmagic() const {
  return returnmagic_;
}
inline void GamePackage_Equipment::set_returnmagic(::google::protobuf::int32 value) {
  set_has_returnmagic();
  returnmagic_ = value;
}

// -------------------------------------------------------------------

// GamePackage

// repeated .GamePackage.Player PlayerList = 1;
inline int GamePackage::playerlist_size() const {
  return playerlist_.size();
}
inline void GamePackage::clear_playerlist() {
  playerlist_.Clear();
}
inline const ::GamePackage_Player& GamePackage::playerlist(int index) const {
  return playerlist_.Get(index);
}
inline ::GamePackage_Player* GamePackage::mutable_playerlist(int index) {
  return playerlist_.Mutable(index);
}
inline ::GamePackage_Player* GamePackage::add_playerlist() {
  return playerlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GamePackage_Player >&
GamePackage::playerlist() const {
  return playerlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::GamePackage_Player >*
GamePackage::mutable_playerlist() {
  return &playerlist_;
}

// repeated .GamePackage.Monster MonsterList = 2;
inline int GamePackage::monsterlist_size() const {
  return monsterlist_.size();
}
inline void GamePackage::clear_monsterlist() {
  monsterlist_.Clear();
}
inline const ::GamePackage_Monster& GamePackage::monsterlist(int index) const {
  return monsterlist_.Get(index);
}
inline ::GamePackage_Monster* GamePackage::mutable_monsterlist(int index) {
  return monsterlist_.Mutable(index);
}
inline ::GamePackage_Monster* GamePackage::add_monsterlist() {
  return monsterlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GamePackage_Monster >&
GamePackage::monsterlist() const {
  return monsterlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::GamePackage_Monster >*
GamePackage::mutable_monsterlist() {
  return &monsterlist_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GamePackage__INCLUDED
